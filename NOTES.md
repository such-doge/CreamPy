# Notes

PIL Notes
---------
* `PIL.Image.crop()` copies metadata which is fine but `==` between two PIL.Image objects also
  compares metadata to determine equality. Numpy does not have this problem.
* If a PIL.Image object is closed, it can be reopened by feeding its own filename into a new object.
  For example, `some_pil_image = Image(some_pil_image.filename)`

Numpy Notes
-----------
* Checking for equality between numpy arrays generated by `imageio.imread()` does not check for
  image metadata.
* `imageio.imread()` does not store the filename in the metadata of the numpy array it produces.
  This can be worked around by assigning an instance variable with the filename.

# General Workflow
------------------
- main.py should only contain argument parsing
- main.py should invoke functions in workflow.py (tentative name) that control program flow.
- All the functions that are involved in calculations/comparisons should be in a separate file.

Parameters
----------
1. Format: In JPEG mode, the script will check for identical headers between files in groups.
   Headers that repeat will only be saved once.
2. Dry run: Don't create any files. Print the groups that pictures have been placed into. Print the
   distance between each file calculated. Print the optimal ordering found.
3. Skip n: Control how many blocks should be skipped. Only 1/n blocks will be checked in the initial
   comparison used to group pictures together.
4. Threshold: Define a percentage threshold that two images must reach to be considered "similar".
5. Lossy: only allowed in JPEG mode. Instead of checking for equality, first compute the difference
   between the RGB values of each picture. Specifically, cast the entire array to signed 16 bit ints
   and then take the absolute value of the difference:`diff = abs(np.int16(img_a) - np.int16(img_b))`
   Then check for any values in an 8x8 block that are greater than a certain number to differentiate
   between noise and actual differences. A good threshold number seems to be 12. The max value can
   be found easily with array.max()

# Tests
-----

main.py:
--------
- test that arguments are parsed correctly?

class MCU:
----------
- test 0->m
- test 8->m
- test 5->m
- test 0->8m
- test 0->8m+n

is_similar_lossy:
--------------------------
- test images with different dimensions
- test images that are identical
- test images with same qtables
- test images with different qtables
- test png images
- test the various wrappers

dimensions of diff:
-------------------
- test diffs with only squares
- test diffs with only right edges
- test diffs with only bottom edges
- test diffs with only bottom and right edges
- test diffs with squares and right edges
- test diffs with squares and bottom edges
- test diffs with squares and both edges
- test diffs with erroneous parameters, like positive edges and 0 edge width

count_and_separate_regions:
---------------------------
- test lists with only squares, right edges, bottom edges, or a corner
- test a list with all four

create_diff:
------------
- test that bad image inputs are handled correctly
- test that images with no differences are handled correctly
- test that a valid image pair produces a valid output
- test that out-of-bound regions are handled correctly
- test that qtables are transferred correctly
